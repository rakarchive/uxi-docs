searchState.loadedDescShard("ataxx", 0, "BitBoard represents a set of squares as a 64 bit bitset. A …\nColor represents all the possible colors that an ataxx …\nEMPTY is an empty BitBoard containing no Squares.\nFile represents a file on the Ataxx Board. Each vertical …\nAn iterator over the variants of File\nFileParseError represents the various errors that can be …\nHash represents the semi-unique checksum of a Position …\nMove represents an Ataxx move which can be played on the …\nMoveList is a basic implementation of <code>MoveStore</code> that is …\nMoveStore is a trait implemented by types which are able …\nN is the number of possible Colors.\nN is the number of possible Pieces.\nN represents the total number of Squares in an Ataxx Board.\nN represents the total number of Files in an Ataxx Board.\nN represents the total number of Ranks in an Ataxx Board.\nNULL Move represents an invalid move.\nPASS Move represents a no move, where only the side to …\nPiece represents all the possible ataxx pieces.\nPosition represents the snapshot of an Ataxx Board, the …\nPositionParseErr represents an error encountered while …\nRank represents a rank on the Ataxx Board. Each horizontal …\nAn iterator over the variants of Rank\nRankParseError represents the various errors that can be …\nSquare represents all the squares present on an Ataxx …\nAn iterator over the variants of Square\nSquareParseError represents the various errors that can be …\nUNIVERSE is a filled BitBoard containing all Squares.\nZERO represents a usable zero or null Hash value.\nafter_move returns a new Position which occurs when the …\nat returns the Piece of the piece present on the given …\nbitboard is a macro which allows creation of BitBoard …\nbitboard is a macro which allows creation of BitBoard …\nbitboards stores BitBoards for the piece configuration of …\ncardinality returns the number of Squares present in the …\nchecksum stores the semi-unique Hash of the current …\ncontains checks if the BitBoard contains the given Square.\ncount_moves returns the number of legal moves in the …\ndouble returns the targets of a jump Move from the given …\neast returns a new BitBoard with all the squares shifted …\neast returns the Square to the East of this one.\nfile returns a BitBoard containing all the squares from …\nfile returns the File of the current Square.\nDisplay allows Hash to be formatted in a human-readable …\nDebug allows Hash to be formatted in a human-readable form.\nDisplay formats the given Move in a human-readable manner. …\nDebug formats the given Move into a human-readable debug …\nDebug implements debug printing of a Color in a …\nImplements displaying the Color in a human-readable form. …\nDebug implements debug printing of a Piece in a …\nImplements displaying the Piece in a human-readable form. …\nDebug implements Debug formatting for a Square. It uses …\nDisplay formats the given Square in the format <code>&lt;file&gt;&lt;rank&gt;</code>…\nDebug implements Debug formatting for a File. It uses …\nDisplay formats the given File into a string. Specifically,\nDebug implements Debug formatting for a Rank. It uses …\nDisplay formats the given Rank into a string. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nfrom_str converts the given string representation of a …\nfrom_str converts the given human-readable string into its …\nfrom_str converts a square given in the format <code>&lt;file&gt;&lt;rank&gt;</code>…\nfrom_str converts the given string representation of a …\nfrom_str converts the given string representation of a …\ngenerate_moves generates the legal moves in the current …\ngenerate_moves_into generates all the legal moves in the …\nhalf-move clock stores the number of half-moves since the …\ninsert puts the given Square into the BitBoard.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nis_disjoint checks if the two BitBoards are disjoint, i.e. …\nis_empty checks if no Moves are stored in the MoveStore.\nis_empty checks if the target BitBoard is empty.\nis_game_over checks if the game is over, i.e. is a win or …\nis_single checks if the given Move is singular in nature. …\nis_subset checks if the given BitBoard is a subset of the …\nis_superset checks if the given BitBoard is a superset of …\nlen returns the number of Moves stored in the MoveStore.\nget_lsb returns the least significant Square from the …\nget_msb returns the most significant Square from the …\nnew creates a new Hash from the given black and white …\nnew returns a new jump Move from the given source Square …\nnew creates a new Position with the given BitBoards and …\nnew creates a new Square from the given File and Rank.\nnew_single returns a new singular Move, where a piece is …\nnorth returns a new BitBoard with all the squares shifted …\nnorth returns the Square to the North of this one.\nNot operator (!) switches the side to move for the Hash.\nnot implements the not unary operator (!) which switches …\nperft is a function to walk the move generation tree of …\nbitboard returns the BitBoard associated to the piece …\npop_lsb pops the least significant Square from the …\npop_msb pops the most significant Square from the BitBoard …\npush adds the given Move to the MoveStore.\nput puts the given piece represented by its Piece on the …\nrank returns a BitBoard containing all the squares from …\nrank returns the Rank of the current Square.\nremove removes the given Square from the BitBoard.\nside_to_move stores the Piece whose turn to move it …\nsingle returns the targets of a singular Move from the …\nSource returns the source Square of the moving piece. This …\nsouth returns a new BitBoard with all the squares shifted …\nsouth returns the Square to the South of this one.\nTarget returns the target Square of the moving piece.\nwest returns a new BitBoard with all the squares shifted …\nwest returns the Square to the West of this one.\nwinner returns the Piece which has won the game. It …")